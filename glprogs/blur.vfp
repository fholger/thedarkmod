!!ARBvp1.0
OPTION ARB_position_invariant;

END

!!ARBfp1.0
OPTION ARB_precision_hint_fastest;

TEMP pos0, pos1, pos2, pos3, pos4;
TEMP coord0, coord1, coord2, coord3, coord4;
TEMP input0, input1, input2, input3, input4;
TEMP avg;

# greebo: Initialise the positions
MOV pos0, fragment.position;
MOV pos1, pos0;
MOV pos2, pos0;
MOV pos3, pos0;
MOV pos4, pos0;

# greebo: Offset the positions by a certain amount to the left/right/top/bottom
ADD pos1.y, pos1.y, -3;
ADD pos2.x, pos2.x, 3;
ADD pos3.y, pos3.y, 4;
ADD pos4.x, pos4.x, -5;

# convert pixel's screen position to a fraction of the screen width & height
# fraction will be between 0.0 and 1.0.
# result is stored in temp1.
MUL  coord0, pos0, program.env[1];
MUL  coord1, pos1, program.env[1];
MUL  coord2, pos2, program.env[1];
MUL  coord3, pos3, program.env[1];
MUL  coord4, pos4, program.env[1];

MUL coord0, coord0, program.env[0];
MUL coord1, coord1, program.env[0];
MUL coord2, coord2, program.env[0];
MUL coord3, coord3, program.env[0];
MUL coord4, coord4, program.env[0];

# pull the color value from _currentRender at texture coordinate input1.
# store the r,g,b,a values in input1.
TEX  input0, coord0, texture[0], 2D;
TEX  input1, coord1, texture[0], 2D;
TEX  input2, coord2, texture[0], 2D;
TEX  input3, coord3, texture[0], 2D;
TEX  input4, coord4, texture[0], 2D;

# greebo: Average the values and pump it into the fragment's color
ADD avg, input0, input1;
ADD avg, avg, input2;
ADD avg, avg, input3;
ADD avg, avg, input4;
MUL avg, avg, 0.2;

MOV result.color, avg;

END