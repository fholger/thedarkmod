!!ARBvp1.0 OPTION ARB_position_invariant;

# VPROG_INTERACTION
# 
# input:
# 
# attrib[8]		TEX0	texture coordinates
# attrib[9]		TEX1	normal
# attrib[10]	TEX2	tangent[0]
# attrib[11]	TEX3	tangent[1]
# COL			vertex color
#
# c[4]	localLightOrigin
# c[5]	localViewOrigin
# c[6]	lightProjection S
# c[7]	lightProjection T
# c[8]	lightProjection Q
# c[9]	lightFalloff S
# c[10]	bumpMatrix S
# c[11]	bumpMatrix T
# c[12]	diffuseMatrix S
# c[13]	diffuseMatrix T
# c[14]	specularMatrix S
# c[15]	specularMatrix T
# c[16]	vertex color modulate
# c[17]	vertex color add
#
# output:
# 
# texture 0 is the cube map
# texture 1 is the per-surface bump map
# texture 2 is the light falloff texture
# texture 3 is the light projection texture
# texture 4 is the per-surface diffuse map
# texture 5 is the per-surface specular map
# texture 6 is the specular lookup table

TEMP	R0, R1, R2;

PARAM	defaultTexCoord = { 0, 0.5, 0, 1 };
PARAM	dirFromSky		= { 0.0, 0.0, 1.0 };


# calculate vector to light in R0
SUB		R0, program.env[4], vertex.position;

# put into texture space for TEX0
DP3		result.texcoord[0].x, vertex.attrib[9], R0;
DP3		result.texcoord[0].y, vertex.attrib[10], R0;
DP3		result.texcoord[0].z, vertex.attrib[11], R0;

# textures 1 takes the base coordinates by the texture matrix
MOV		result.texcoord[1], defaultTexCoord;
DP4 	result.texcoord[1].x, vertex.attrib[8], program.env[10];
DP4 	result.texcoord[1].y, vertex.attrib[8], program.env[11];

# texture 2 has one texgen
MOV		result.texcoord[2], defaultTexCoord;
DP4		result.texcoord[2].x, vertex.position, program.env[9];

# texture 3 has three texgens
DP4		result.texcoord[3].x, vertex.position, program.env[6];
DP4		result.texcoord[3].y, vertex.position, program.env[7];
DP4		result.texcoord[3].w, vertex.position, program.env[8];

# textures 4 takes the base coordinates by the texture matrix
MOV		result.texcoord[4], defaultTexCoord;
DP4		result.texcoord[4].x, vertex.attrib[8], program.env[12];
DP4		result.texcoord[4].y, vertex.attrib[8], program.env[13];

# textures 5 takes the base coordinates by the texture matrix
MOV		result.texcoord[5], defaultTexCoord;
DP4		result.texcoord[5].x, vertex.attrib[8], program.env[14];
DP4		result.texcoord[5].y, vertex.attrib[8], program.env[15];

# calculate vector to viewer in R0
SUB		R0, program.env[5], vertex.position;

# put into texture space for TEX6
DP3		result.texcoord[6].x, vertex.attrib[9], R0;
DP3		result.texcoord[6].y, vertex.attrib[10], R0;
DP3		result.texcoord[6].z, vertex.attrib[11], R0;

# put Sky Dir into texture space for TEX7
DP3		result.texcoord[7].x, vertex.attrib[9],	 dirFromSky;
DP3		result.texcoord[7].y, vertex.attrib[10], dirFromSky;
DP3		result.texcoord[7].z, vertex.attrib[11], dirFromSky;

# generate the vertex color, which can be 1.0, color, or 1.0 - color
# for 1.0 : env[16] = 0, env[17] = 1
# for color : env[16] = 1, env[17] = 0
# for 1.0-color : env[16] = -1, env[17] = 1
MAD		result.color, vertex.color, program.env[16], program.env[17];

END


#==================================================================================

!!ARBfp1.0 
OPTION ARB_precision_hint_fastest;

# texture 0 is the cube map
# texture 1 is the per-surface bump map
# texture 2 is the light falloff texture
# texture 3 is the light projection texture
# texture 4 is the per-surface diffuse map
# texture 5 is the per-surface specular map
# texture 6 is the specular lookup table

# env[0] is the diffuse modifier
# env[1] is the specular modifier

# Scale the normal map scale up by a factor of 1.5.
PARAM	subOne		= { -1.4, -1.4, -1.0, -1.0 };
PARAM	scaleTwo	= {  2.8,  2.8,  2.0,  2.0 };
#PARAM	subOneN		= { -1.0, -1.0, -1.0, -1.0 };
#PARAM	scaleTwoN	= {  2.0,  2.0,  2.0,  2.0 };
PARAM	half		= {  0.5,  0.5,  0.5,  0.5 };

#---------------------------------------------------------
# Regardless of the name, the fresnel parameters have diverse usage.
# Note that, some multipliers are really insane values, 
# this enable us to utilize High Dynamic Range
#---------------------------------------------------------
# Pramaeters are, respectively:		unsused, (1 - RI) specular correction, rimcontrib, unused
#---------------------------------------------------------
PARAM	fresnelParms		= { 1.0, .23, .5, 1.0  }; 	#spec correc. 30			
#---------------------------------------------------------

#---------------------------------------------------------
# Pramaeters are, respectively:		Unsused, RI + spec correction, specular multiplier, rim power;
#---------------------------------------------------------
PARAM   fresnelParms2		= { .2, .023, 120.0, 4.0 }; # SPEC MUL WAS 200, 350, 120
#---------------------------------------------------------
# Pramaeters are, respectively:		ambient rim scale, diffuse rim scale, min. spec exp, max spec exp;
#---------------------------------------------------------
PARAM   lightParms			= { .7, 1.8, 10.0, 30.0 }; ## rim 4.4, 0.8

PARAM	cubemapLookupVec		= { 0.33333, 0.33333, 0.33333 };

PARAM	colGround				= { .35, .32, .32, 1.0 };
PARAM	colSky					= { .88, .88, .88, 1.0 };
#---------------------------------------------------------

#---------------------------------------------------------
TEMP	lightProjFallOff, fresnelTerm, ambientContrib, rimLight;
#---------------------------------------------------------

TEMP	toLight, light, toViewer, dirSky, halfAngle, color, R1, R2, R3, localNormal, ambientLightParams;

#
# the amount of light contacting the fragment is the
# product of the two light projections and the surface
# bump mapping
#

# normalize the direction to the light
DP3		toLight, fragment.texcoord[0],fragment.texcoord[0];
RSQ		toLight, toLight.x;
MUL		toLight, toLight.x, fragment.texcoord[0];

# normalize the direction to the viewer
DP3		toViewer, fragment.texcoord[6],fragment.texcoord[6];
RSQ		toViewer, toViewer.x;
MUL		toViewer, toViewer.x, fragment.texcoord[6];

# load the filtered normal map
TEX		localNormal, fragment.texcoord[1], texture[1], 2D;
MOV		localNormal.x, localNormal.a;
MAD		localNormal.xyz, localNormal, scaleTwo, subOne;

#---------------------------------------------------------
# localNormal (normalize)
#---------------------------------------------------------
DP3		R1.w, localNormal, localNormal;
RSQ		R1.w, R1.w;
MUL		localNormal.xyz, R1.w, localNormal;
#---------------------------------------------------------
# diffuse dot product
DP3_SAT	light, toLight, localNormal;

# modulate by the light projection
TXP 	R1, fragment.texcoord[3], texture[3], 2D;

# modulate by the light falloff
TXP 	R2, fragment.texcoord[2], texture[2], 2D;

#---------------------------------------------------------
# Store light Projection and Fall off to a variable for later use.
#---------------------------------------------------------
MUL 	lightProjFallOff, R1, R2;

# modulate by the diffuse map
TEX		color, fragment.texcoord[4], texture[4], 2D;

#---------------------------------------------------------
# Calculate Fresnel reflectance approximation for Diffuse lighting
#---------------------------------------------------------
DP3_SAT fresnelTerm.x, toViewer, localNormal;
SUB		fresnelTerm, 1, fresnelTerm;
POW		fresnelTerm, fresnelTerm.x, fresnelParms2.w;
SUB_SAT	R1, light, .3;
MIN		R1, R1, fresnelParms.zzzz;

MUL		rimLight, R1, fresnelTerm;

# read specular map
TEX		R2, fragment.texcoord[5], texture[5], 2D;

SUB		R1, program.env[1], 0.001;  # See if there's a specular map for this material
CMP		R2, R1, .026, R2;		#  If not then give a constant artifical value as spec.
#MAD		R3, R2, .5, .5;

MUL		rimLight, rimLight, lightParms.y;


# calculate the half angle vector and normalize
ADD		halfAngle, toLight, toViewer;
DP3		R1, halfAngle, halfAngle;
RSQ		R1, R1.x;
MUL		halfAngle.xyz, halfAngle, R1;

#---------------------------------------------------------
# calculate specular
#---------------------------------------------------------
DP3_SAT		R1, halfAngle, localNormal;
#---------------------------------------------------------

#---------------------------------
# Convert spec. exponent to ralnge lightParms.w - lightParms.z 
#---------------------------------
LRP		R2.a, R2.z, lightParms.w, lightParms.z;
#---------------------------------

# Don't use specular lookup texture. Use power instead.
POW		R1, R1.x, R2.a;
#POW		R1, R1.x, 12.0.r;
#MOV		R1.y, 0.047058823529411764705882352941176;
#TEX		R1, R1, texture[6], 2D;

#---------------------------------------------------------
MUL		R1, R1, fresnelParms2.z;
#---------------------------------------------------------

#---------------------------------------------------------
# Calculate & add fresnel reflectance approximation for specular
#---------------------------------------------------------
MAD		R3, fresnelTerm.x, fresnelParms.y, fresnelParms2.y;		
MUL		R1, R1, R3;
#---------------------------------------------------------

# modulate by the specular map
MUL		R3, color, .25;
MUL		R3, R2, R3;
MAD		R3, R2, 0.75, R3;
MUL		R1, R1, R3;

# light color
#MUL 	color, color, program.env[0];

#---------------------------------------------------------
# Calculate Self Shadow term and modulate with result.
#---------------------------------------------------------
MUL_SAT		R2, toLight.z, 4.0;

MAD			light, rimLight, R2, light;

MAD			color, R1, R2, color;
MUL			color, light, color;

#Dont use specular color
#MUL 	R1, R1, program.env[1];
MUL 	color, color, program.env[0];


#---------------------------------------------------------

MUL			color, color, lightProjFallOff;
#---------------------------------------------------------

# modify by the vertex color
MUL		result.color.xyz, color, fragment.color;

END
