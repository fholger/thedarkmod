!!ARBvp1.0

OPTION ARB_position_invariant;

# VPROG_INTERACTION
#
# input:
#
# attrib[8]		TEX0	texture coordinates
# attrib[9]		TEX1	normal
# attrib[10]	TEX2	tangent[0]
# attrib[11]	TEX3	tangent[1]
# attrib[3] (former COL)	vertex color
#
# c[4]	localLightOrigin
# c[5]	localViewOrigin
# c[6]	lightProjection S
# c[7]	lightProjection T
# c[8]	lightProjection Q
# c[9]	lightFalloff S
# c[10]	bumpMatrix S
# c[11]	bumpMatrix T
# c[12]	diffuseMatrix S
# c[13]	diffuseMatrix T
# c[14]	specularMatrix S
# c[15]	specularMatrix T
# c[16]	vertex color modulate
# c[17]	vertex color add
# c[21]	world up direction vector in object space
#
# output:
#
# texture 0 is the cube map
# texture 1 is the per-surface bump map
# texture 2 is the light falloff texture
# texture 3 is the light projection texture
# texture 4 is the per-surface diffuse map
# texture 5 is the per-surface specular map
# texture 6 is the specular lookup table

TEMP	R0, R1, R2;

PARAM	defaultTexCoord = { 0, 0.5, 0, 1 };
PARAM	dirFromSky		= { 0.0, 0.0, 1.0 };

# textures 1 takes the base coordinates by the texture matrix
MOV	result.texcoord[1], defaultTexCoord;
DP4 	result.texcoord[1].x, vertex.attrib[8], program.env[10];
DP4 	result.texcoord[1].y, vertex.attrib[8], program.env[11];

# texture 2 has one texgen
MOV	result.texcoord[2], defaultTexCoord;
DP4	result.texcoord[2].x, vertex.position, program.env[9];

# texture 3 has three texgens
DP4	result.texcoord[3].x, vertex.position, program.env[6];
DP4	result.texcoord[3].y, vertex.position, program.env[7];
DP4	result.texcoord[3].w, vertex.position, program.env[8];

# textures 4 takes the base coordinates by the texture matrix
MOV	result.texcoord[4], defaultTexCoord;
DP4	result.texcoord[4].x, vertex.attrib[8], program.env[12];
DP4	result.texcoord[4].y, vertex.attrib[8], program.env[13];

# textures 5 takes the base coordinates by the texture matrix
MOV	result.texcoord[5], defaultTexCoord;
DP4	result.texcoord[5].x, vertex.attrib[8], program.env[14];
DP4	result.texcoord[5].y, vertex.attrib[8], program.env[15];

# calculate vector to viewer in R0
SUB	R0, program.env[5], vertex.position;

# put into texture space for TEX6
DP3	result.texcoord[6].x, vertex.attrib[9], R0;
DP3	result.texcoord[6].y, vertex.attrib[10], R0;
DP3	result.texcoord[6].z, vertex.attrib[11], R0;

# put Sky Dir into texture space for TEX7
DP3	result.texcoord[7].x, vertex.attrib[9], program.env[21];
DP3	result.texcoord[7].y, vertex.attrib[10], program.env[21];
DP3	result.texcoord[7].z, vertex.attrib[11], program.env[21];

# generate the vertex color, which can be 1.0, color, or 1.0 - color
# for 1.0 : env[16] = 0, env[17] = 1
# for color : env[16] = 1, env[17] = 0
# for 1.0-color : env[16] = -1, env[17] = 1
MAD	result.color, vertex.attrib[3], program.env[16], program.env[17];

END

#==================================================================================

!!ARBfp1.0

OPTION ARB_precision_hint_fastest;

# texture 0 is the cube map
# texture 1 is the per-surface bump map
# texture 2 is the light falloff texture
# texture 3 is the light projection texture
# texture 4 is the per-surface diffuse map
# texture 5 is the per-surface specular map
# texture 6 is the specular lookup table

# env[0] is the diffuse modifier
# env[1] is the specular modifier

# parameters : ambient rim scale, diffuse rim scale, min spec exp, max spec exp
PARAM   lightParms	= { .7, 1.8, 4.0, 20.0 };
PARAM	colSky		= { .88, .88, .88, 1.0 };
PARAM	colGround	= { .35, .32, .32, 1.0 };

TEMP	localNormal, toViewer, light, color, R1, R2, lightProj;

# normalized view direction
DP3		R1.w, fragment.texcoord[6],fragment.texcoord[6];
RSQ		R1.w, R1.w;
MUL		toViewer.xyz, R1.w, fragment.texcoord[6];

# load normalmap and normalize
TEX		localNormal, fragment.texcoord[1], texture[1], 2D;
MOV		localNormal.x, localNormal.a;
MAD		localNormal.xyz, localNormal, 2.0, -1.0;

DP3		R1.w, localNormal, localNormal;
RSQ		R1.w, R1.w;
MUL		localNormal.xyz, R1.w, localNormal;

# main diffuse shading
DP3		light.w, localNormal, fragment.texcoord[7];
MAD		light.w, light.w, 0.5, 0.5;
LRP		light.xyz, light.w, colSky, colGround;

# light projection and falloff
TXP 		R1.xyz, fragment.texcoord[3], texture[3], 2D;
TXP 		R2.xyz, fragment.texcoord[2], texture[2], 2D;
MUL 		lightProj.xyz, R1, R2;

# load diffuse and specular maps
TEX		color, fragment.texcoord[4], texture[4], 2D;
TEX		R2, fragment.texcoord[5], texture[5], 2D;

# calculate specularity
DP3_SAT	R1.y, toViewer, localNormal;
LRP		R2.w, R2.g, lightParms.w, lightParms.z;
POW		R1.x, R1.y, R2.w;
MUL		R1.x, R1.x, 0.65;

# "diffuse" fresnel effect
TEMP		fresnelTerm;
SUB		fresnelTerm.x, 1.0, R1.y;
POW		fresnelTerm.x, fresnelTerm.x, R2.w;
ADD_SAT	R1.w, toViewer.z, toViewer.z;
MUL 		fresnelTerm.x, fresnelTerm.x, R1.w;
MAD		light.xyz, fresnelTerm.x, 0.4, light;

# modulate diffuse and specular maps
MUL 		color.xyz, color, program.env[0];
MUL 		R2.xyz, R2, program.env[1];

# combine terms
MAD		color.xyz, R1.x, R2, color;
MUL		color.xyz, light, color;
MUL		color.xyz, color, lightProj;

# modify by the vertex color
MUL		result.color.xyz, color, fragment.color;

END